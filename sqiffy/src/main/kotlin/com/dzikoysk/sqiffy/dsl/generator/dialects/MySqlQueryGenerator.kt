package com.dzikoysk.sqiffy.dsl.generator.dialects

import com.dzikoysk.sqiffy.dsl.ComparisonCondition
import com.dzikoysk.sqiffy.dsl.ComparisonOperator
import com.dzikoysk.sqiffy.dsl.Expression
import com.dzikoysk.sqiffy.dsl.QuoteType
import com.dzikoysk.sqiffy.dsl.generator.ArgumentType.COLUMN
import com.dzikoysk.sqiffy.dsl.generator.Arguments
import com.dzikoysk.sqiffy.dsl.generator.ExpressionColumns
import com.dzikoysk.sqiffy.dsl.generator.ParameterAllocator
import com.dzikoysk.sqiffy.dsl.generator.QueryColumn
import com.dzikoysk.sqiffy.dsl.generator.SqlQueryGenerator.GeneratorResult
import com.dzikoysk.sqiffy.dsl.generator.SqlQueryGenerator.InsertGeneratorResult
import com.dzikoysk.sqiffy.shared.multiline

object MySqlQueryGenerator : GenericMySqlQueryGenerator(autogeneratedKeyAsNull = false)

open class GenericMySqlQueryGenerator(private val autogeneratedKeyAsNull: Boolean) : GenericQueryGenerator() {

    override fun createInsertQuery(
        allocator: ParameterAllocator,
        tableName: String,
        columns: List<QueryColumn>,
        autogeneratedKey: QueryColumn?
    ): InsertGeneratorResult {
        val arguments = Arguments(allocator)

        val values = columns.joinToString(
            separator = ", ",
            transform = { ":${arguments.createArgument(COLUMN, it.name)}" }
        )

        val autogeneratedKeyAsNullEnabled = autogeneratedKey?.takeIf { autogeneratedKeyAsNull }

        return InsertGeneratorResult(
            updateResult = GeneratorResult(
                query =
                multiline(
                    """
                        INSERT INTO ${tableName.toQuoted()}
                        (${columns.joinToString(separator = ", ") { it.name.toQuoted() }}${autogeneratedKeyAsNullEnabled?.let { ", ${it.name.toQuoted()}" } ?: ""})
                        VALUES ($values${autogeneratedKeyAsNullEnabled?.let { ", NULL" } ?: ""});
                    """
                ),
                arguments = arguments
            )
        )
    }

    override fun createUpdateQuery(
        allocator: ParameterAllocator,
        tableName: String,
        argumentColumns: List<QueryColumn>,
        expressionColumns: ExpressionColumns,
        where: String?
    ): GeneratorResult {
        val arguments = Arguments(allocator)

        val argumentValues = argumentColumns.joinToString(
            separator = ", ",
            transform = { "${it.name.toQuoted()} = :${arguments.createArgument(COLUMN, it.name)}" }
        )

        return GeneratorResult(
            query =
            multiline("""
                    UPDATE ${tableName.toQuoted()} 
                    SET ${listOf(argumentValues, expressionColumns.toUpdateValues()).filter { it.isNotBlank() }.joinToString(separator = ", ")}
                    ${where?.let { "WHERE $it" } ?: ""}
                """),
            arguments = arguments
        )
    }

    override fun quoteType(): QuoteType = QuoteType.BACKTICK

    override fun <SOURCE, RESULT> createExpression(allocator: ParameterAllocator, expression: Expression<SOURCE, RESULT>): GeneratorResult =
        when (expression) {
            is ComparisonCondition<*, *> -> {
                when (expression.operator) {
                    ComparisonOperator.ILIKE, ComparisonOperator.NOT_ILIKE -> {
                        val leftResult = createExpression(allocator, expression.left)
                        val rightResult = createExpression(allocator, expression.right)
                        val operator = if (expression.operator == ComparisonOperator.ILIKE) "LIKE" else "NOT LIKE"

                        GeneratorResult(
                            query = "LOWER(${leftResult.query}) $operator LOWER(${rightResult.query})",
                            arguments = (leftResult.arguments + rightResult.arguments)
                        )
                    }
                    else -> super.createExpression(allocator, expression)
                }
            }
            else -> super.createExpression(allocator, expression)
        }

}