package com.dzikoysk.sqiffy.dsl.generator.dialects

import com.dzikoysk.sqiffy.dsl.Column
import com.dzikoysk.sqiffy.dsl.generator.ArgumentType.COLUMN
import com.dzikoysk.sqiffy.dsl.generator.Arguments
import com.dzikoysk.sqiffy.dsl.generator.ExpressionColumns
import com.dzikoysk.sqiffy.dsl.generator.ParameterAllocator
import com.dzikoysk.sqiffy.dsl.generator.QueryColumn
import com.dzikoysk.sqiffy.dsl.generator.SqlQueryGenerator.GeneratorResult
import com.dzikoysk.sqiffy.dsl.generator.SqlQueryGenerator.InsertGeneratorResult
import com.dzikoysk.sqiffy.shared.multiline

object PostgreSqlQueryGenerator : GenericQueryGenerator() {

    override fun createInsertQuery(
        allocator: ParameterAllocator,
        tableName: String,
        columns: List<QueryColumn>,
        autogeneratedKey: QueryColumn?
    ): InsertGeneratorResult {
        val arguments = Arguments(allocator)
        val values = createInsertValues(arguments, columns)

        return InsertGeneratorResult(
            updateResult = GeneratorResult(
                query =
                multiline(
                    """
                        INSERT INTO ${tableName.toQuoted()} 
                        (${columns.joinToString(separator = ", ") { it.name.toQuoted() }}) 
                        VALUES ($values)
                    """
                ),
                arguments = arguments
            )
        )
    }

    private fun createInsertValues(arguments: Arguments, columns: List<QueryColumn>): String =
        columns.joinToString(
            separator = ", ",
            transform = {
                when {
                    it.type.isEnum -> "CAST(:${arguments.createArgument(COLUMN, it.name)} AS ${it.dbType})"
                    else -> ":${arguments.createArgument(COLUMN, it.name)}"
                }
            }
        )

    override fun createUpdateQuery(
        allocator: ParameterAllocator,
        tableName: String,
        argumentColumns: List<QueryColumn>,
        expressionColumns: ExpressionColumns,
        where: String?
    ): GeneratorResult {
        val arguments = Arguments(allocator)
        val values = createUpdateValues(arguments, argumentColumns)

        return GeneratorResult(
            query =
                multiline("""
                    UPDATE ${tableName.toQuoted()} 
                    SET ${listOf(values, expressionColumns.toUpdateValues()).filter { it.isNotBlank() }.joinToString(separator = ", ")}
                    ${where?.let { "WHERE $it" } ?: ""}
                """),
            arguments = arguments
        )
    }

    private fun createUpdateValues(arguments: Arguments, columns: List<QueryColumn>): String =
        columns.joinToString(
            separator = ", ",
            transform = {
                it.name.toQuoted() + " = " + when {
                    it.type.isEnum -> "CAST(:${arguments.createArgument(COLUMN, it.name)} AS ${it.dbType})"
                    else -> ":${arguments.createArgument(COLUMN, it.name)}"
                }
            }
        )


    data class UpsertGeneratorResult(
        val query: String,
        val insertArguments: Arguments = Arguments(ParameterAllocator()),
        val updateArguments: Arguments = Arguments(ParameterAllocator())
    )

    fun createUpsertQuery(
        allocator: ParameterAllocator,
        tableName: String,
        insertColumns: List<QueryColumn>,
        updateColumns: List<QueryColumn>,
        conflictingColumns: List<Column<*>>,
        expressionColumns: ExpressionColumns,
        where: String?
    ): UpsertGeneratorResult {
        val insertArguments = Arguments(allocator)
        val values = createInsertValues(insertArguments, insertColumns)
        val upsertArguments = Arguments(allocator)
        val updateValues = createUpdateValues(upsertArguments, updateColumns)

        return UpsertGeneratorResult(
            query =
                multiline("""
                    INSERT INTO ${tableName.toQuoted()} 
                    (${insertColumns.joinToString(separator = ", ") { it.name.toQuoted() }})
                    VALUES ($values)
                    ON CONFLICT (${conflictingColumns.joinToString(separator = ", ") { it.name.toQuoted() }})
                    DO UPDATE SET ${listOf(updateValues, expressionColumns.toUpdateValues()).filter { it.isNotBlank() }.joinToString(separator = ", ")}
                    ${where?.let { "WHERE $it" } ?: ""}
                """),
            insertArguments = insertArguments,
            updateArguments = upsertArguments
        )
    }

}